<!--GOOD VERSION----------------------------------------------------------------------------------->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Night Sky Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { 
            background-color: #0a0e1a; 
            margin: 0; 
            overflow: hidden; 
            color: white; 
            text-align: center;
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block;
        }
        /* #controls { 
            position: absolute; 
            top: 5%; 
            left: 50%;  
            transform: translate(-50%);
            z-index: 10;
            background-color: rgba(25, 29, 41, 0.7);
            padding: 10px;
            border-radius: 8px;
        } */
        .controls {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            z-index: 10;
            width: 90%;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            padding: 10px;
            border-radius: 8px;
        }
        .switch-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .switch__text {
            font-size: 16px;
            color: white;
        }
        .switch__input {
            clip: rect(1px, 1px, 1px, 1px);
            clip-path: inset(50%);
            height: 1px;
            width: 1px;
            margin: -1px;
            overflow: hidden;
            padding: 0;
            position: absolute;
        }
        
        .switch__label {
            position: relative;
            display: inline-block;
            width: 120px;
            height: 60px;
            background-color: #2B2B2B;
            border: 5px solid #5B5B5B;
            border-radius: 9999px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(.46,.03,.52,.96);
        }
        
        .switch__indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateX(-72%);
            display: block;
            width: 40px;
            height: 40px;
            background-color: #7B7B7B;
            border-radius: 9999px;
            box-shadow: 10px 0px 0 0 rgba(#000000, 0.2) inset;
        
            &::before,
            &::after {
                position: absolute;
                content: '';
                display: block;
                background-color: #FFFFFF;
                border-radius: 9999px;
            }
        
            &::before {
                top: 7px;
                left: 7px;
                width: 9px;
                height: 9px;
                background-color: #FFFFFF;
                opacity: 0.6;
            }
        
            &::after {
                bottom: 8px;
                right: 6px;
                width: 14px;
                height: 14px;
                background-color: #FFFFFF;
                opacity: 0.8;
            }
        }
        
        .switch__decoration {
            position: absolute;
            top: 65%;
            left: 50%;
            display: block;
            width: 5px;
            height: 5px;
            background-color: #FFFFFF;
            border-radius: 9999px;
            animation: twinkle 0.8s infinite -0.6s;
        
            &::before,
            &::after {
                position: absolute;
                display: block;
                content: '';
                width: 5px;
                height: 5px;
                background-color: #FFFFFF;
                border-radius: 9999px;
            }
        
            &::before {
                top: -20px;
                left: 10px;
                opacity: 1;
                animation: twinkle 0.6s infinite;
            }
        
            &::after {
                top: -7px;
                left: 30px;
                animation: twinkle 0.6s infinite -0.2s;
            }
        }
        
        @keyframes twinkle {
            50% { opacity: 0.2; }
        }
        
        .switch__indicator {
            &,
            &::before,
            &::after {
                transition: all 0.4s cubic-bezier(.46,.03,.52,.96);
            }
        }
        
        .switch__input:checked + .switch__label {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-color: #8b5cf6;
        
            .switch__indicator {
                background-color: #ECD21F;
                box-shadow: none;
                transform: translate(-50%, -50%) translateX(72%);
            
                &::before,
                &::after {
                    display: none;
                }
            }
        
            /* .switch__decoration {
                top: 50%;
                transform: translate(0%, -50%);
                animation: cloud 8s linear infinite;
            
                width: 20px;
                height: 20px;
            
                &::before {
                    width: 10px;
                    height: 10px;
                    top: auto;
                    bottom: 0;
                    left: -8px;
                    animation: none;
                }
            
                &::after {
                    width: 15px;
                    height: 15px;
                    top: auto;
                    bottom: 0;
                    left: 16px;
                    animation: none;
                }
            
                &,
                &::before,
                &::after {
                    border-radius: 9999px 9999px 0 0;
                }
            
                &::after {
                    border-bottom-right-radius: 9999px;
                }
            } */
        }
        .switch__input:checked + .switch__label .switch__decoration {
            display: none;
            animation: none; /* Disable twinkle animation when checkbox is checked */
        }
        
        @keyframes cloud {
            0% {
                transform: translate(0%, -50%);
            }
            50% {
                transform: translate(-50%, -50%);
            }
            100% {
                transform: translate(0%, -50%);
            }
        }

        button { /* input was there */
            margin: 0 5px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #666;
            background-color: #222;
            color: white;
        }
        button {
            background-color: #334;
            cursor: pointer;
        }
        button:hover {
            background-color: #445;
        }
        #constellation-info {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #aaa;
        }
        .constellation-label {
            position: absolute;
            color: rgba(150, 200, 255, 0.8);
            font-size: 12px;
            pointer-events: none;
        }
        #status {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: yellow;
            font-size: 16px;
            z-index: 20;
        }
        .loading-spinner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it is above everything */
        }
        .outside {
            position: absolute;
            width: 300px;
            height: 300px;
            border: 1px solid #ffffe9;
            border-radius: 50%;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            margin: auto;
            animation: ro 5s infinite linear;
        }

        .star {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #ffe179;
            left: 5px;
            top: 5px;
            position: absolute;
            animation: ro 2.5s infinite linear;
        }

        .dot {
            background: #000;
            position: absolute;
        
        }

        #dot1 {
            width: 20px;
            height: 20px;
            border-radius: 10px;
            opacity: .2;
            top: 20px;
            left: 20px;
        }

        #dot2 {
            width: 10px;
            height: 10px;
            border-radius: 5px;
            opacity: .3;
            top: 40px;
            left: 40px;
        }

        #dot3 {
            width: 6px;
            height: 6px;
            border-radius: 3px;
            opacity: .4;
            top: 48px;
            left: 20px;
        }

        @keyframes ro {
            from {
              transform: rotate(0deg);
            }
            to {
              transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <!-- <div id="controls">
        <form id="skyForm"> -->
            <!-- <label for="date">Date:</label> -->
            <!-- <input type="date" id="date"> -->
            <!-- <label for="latitude">Latitude:</label>
            <input type="number" id="latitude" step="0.01" value="43.6532">
            <label for="longitude">Longitude:</label>
            <input type="number" id="longitude" step="0.01" value="-79.3832"> -->
            <!-- <button type="submit">Show Sky</button> -->
            <!-- <label for="showLabels">
                <input type="checkbox" id="showLabels" unchecked> Show Labels
            </label>
            <label for="showMilkyWay">
                <input type="checkbox" id="showMilkyWay" checked> Milky Way
            </label>
        </form>
    </div> -->
    <div class="controls">
        <div class="switch-group">
            <span class="switch__text">Show Labels</span>
            <input type="checkbox" class="switch__input" id="showLabels">
            <label class="switch__label" for="showLabels">
                <span class="switch__indicator"></span>
                <span class="switch__decoration"></span>
            </label>
        </div>
    
        <div class="switch-group">
            <input type="checkbox" class="switch__input" id="showMilkyWay">
            <label class="switch__label" for="showMilkyWay">
                <span class="switch__indicator"></span>
                <span class="switch__decoration"></span>
            </label>
            <span class="switch__text">Milky Way</span>
        </div>
    </div>
    <!-- <div id="constellation-info"></div> -->
    <div id="status"></div>
    <canvas id="skyCanvas"></canvas>
    <div id="constellation-popup" style="display: none; position: absolute; background-color: rgba(25, 29, 41, 0.9); border-radius: 8px; padding: 15px; color: white; max-width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.5); z-index: 100;">
        <h3 id="popup-title" style="margin-top: 0; color: #8af;"></h3>
        <div id="popup-description">
        </div>
        <button id="close-popup" style="background-color: #334; border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Close</button>
    </div>

    <div id="loadingSpinner" class="loading-spinner" style="display:none;">
        <div class="outside">
            <div class="star">
              <div class="dot" id="dot1"></div>
              <div class="dot" id="dot2"></div>
              <div class="dot" id="dot3"></div>
            </div>  
          </div>
    </div>
    
    <script>
        const canvas = document.getElementById("skyCanvas");
        const ctx = canvas.getContext("2d");
        // const constellationInfo = document.getElementById("constellation-info");
        const statusDiv = document.getElementById("status");
        let constellationData = [];
        let starData = [];
        let milkyWayData = [];
        
        // Resize canvas to fill window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (starData.length > 0) {
                updateSkyMap();
            }
        }

        // skyForm.addEventListener('submit', function(event) {
        //     event.preventDefault();
        //     updateSkyMap();
        // });
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        function localSiderealTime(date, longitude) {
            const JD = (Date.parse(date) / 86400000) + 2440587.5;
            const T = (JD - 2451545.0) / 36525;
            let GMST = 280.46061837 + 360.98564736629 * (JD - 2451545) + T * T * (0.000387933 - T / 38710000);
            GMST = (GMST % 360 + 360) % 360;
            return (GMST + longitude) % 360;
        }

        function equatorialToHorizontal(ra, dec, lat, lst) {
            // Validate inputs
            if (isNaN(ra) || isNaN(dec) || isNaN(lat) || isNaN(lst)) {
                console.error(`Invalid input: RA=${ra}, DEC=${dec}, LAT=${lat}, LST=${lst}`);
                return [NaN, NaN];
            }

            // Calculate hour angle (H)
            const H = (lst - ra + 360) % 360;
            const Hrad = toRadians(H);
            const Decrad = toRadians(dec);
            const Latrad = toRadians(lat);

            // Calculate altitude (alt) and azimuth (az)
            const sinAlt = Math.sin(Decrad) * Math.sin(Latrad) + 
                           Math.cos(Decrad) * Math.cos(Latrad) * Math.cos(Hrad);
            const altClamped = Math.max(-1, Math.min(1, sinAlt)); // Clamp to avoid floating point errors
            const alt = Math.asin(altClamped);

            const sinAz = -Math.sin(Hrad) * Math.cos(Decrad) / Math.cos(alt);
            const cosAz = (Math.sin(Decrad) - Math.sin(Latrad) * Math.sin(alt)) / 
                          (Math.cos(Latrad) * Math.cos(alt));
            const az = Math.atan2(sinAz, cosAz);

            // Convert to degrees
            const azDeg = (az * 180 / Math.PI + 360) % 360;
            const altDeg = alt * 180 / Math.PI;

            return [azDeg, altDeg];
        }


        async function loadStars() {
            statusDiv.textContent = "Loading star data...";
            
            try {
                const starsUrl = "https://raw.githubusercontent.com/ofrohn/d3-celestial/master/data/stars.6.json";
                const constellationsUrl = "https://raw.githubusercontent.com/ofrohn/d3-celestial/master/data/constellations.lines.json";
                const constellationsNamesUrl = "https://raw.githubusercontent.com/ofrohn/d3-celestial/master/data/constellations.json";
                const milkyWayUrl = "https://raw.githubusercontent.com/ofrohn/d3-celestial/master/data/milkyway.json";
                
                const [starsResp, constLinesResp, constNamesResp, milkyWayResp] = await Promise.all([
                    fetch(starsUrl),
                    fetch(constellationsUrl),
                    fetch(constellationsNamesUrl),
                    fetch(milkyWayUrl)
                ]);
                
                const starsData = await starsResp.json();
                const constellationsData = await constLinesResp.json();
                const constellationsNames = await constNamesResp.json();
                const milkyWayData = await milkyWayResp.json();
                
                // Check data format and log it for debugging
                console.log("Constellations Names:", constellationsNames);
                
                // Handle data format issue - constellationsNames might be an object with a 'features' property
                const namesList = Array.isArray(constellationsNames) ? constellationsNames : 
                                  (constellationsNames.features || []);
                
                // Merge constellation data with names
                const constellationsWithNames = constellationsData.features.map(constellation => {
                    // Find the name data by id
                    let nameData = null;
                    for (let i = 0; i < namesList.length; i++) {
                        if (namesList[i].id === constellation.id) {
                            nameData = namesList[i];
                            break;
                        }
                    }
                    
                    return {
                        ...constellation,
                        properties: {
                            ...constellation.properties,
                            name: nameData ? nameData.properties.name : constellation.id
                        }
                    };
                });
                
                statusDiv.textContent = "Star data loaded successfully!";
                setTimeout(() => { statusDiv.textContent = ""; }, 3000);
                
                return { 
                    stars: starsData.features, 
                    constellations: constellationsWithNames,
                    milkyWay: milkyWayData.features
                };
            } catch (error) {
                console.error("Error loading star data:", error);
                statusDiv.textContent = "Error loading star data. Using fallback data.";
                
                // Fallback to simple basic data
                return {
                    stars: [],
                    constellations: [],
                    milkyWay: []
                };
            }
        }
        
        function transformCoords(az, alt) {
            const radius = Math.min(canvas.width, canvas.height) / 2 * 0.9;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const r = (90 - alt) / 90 * radius;
            const px = centerX + r * Math.sin(toRadians(az));
            const py = centerY - r * Math.cos(toRadians(az));
            return [px, py];
        }
        
        function getMagnitudeSize(mag) {
            // Make brighter stars (smaller magnitude) appear larger
            return Math.max(0.5, (5 - mag * 0.8)/2);
        }
        
        function getStarColor(bv) {
            // B-V color index to RGB
            if (bv < -0.3) return "#9bb0ff"; // Hot blue
            else if (bv < 0.0) return "#aabfff"; // Blue
            else if (bv < 0.3) return "#cad7ff"; // Blue-white
            else if (bv < 0.6) return "#f8f7ff"; // White
            else if (bv < 1.0) return "#fff4ea"; // Yellow-white
            else if (bv < 1.5) return "#ffd2a1"; // Yellow
            else return "#ffcc6f";               // Orange
        }

        function drawMilkyWay(milkyWayData, lat, lst) {
            if (!milkyWayData || milkyWayData.length === 0 || !document.getElementById("showMilkyWay").checked) return;

            // Create an off-screen canvas for better blending
            const offCanvas = document.createElement('canvas');
            offCanvas.width = canvas.width;
            offCanvas.height = canvas.height;
            const offCtx = offCanvas.getContext('2d');

            // Draw different layers of the Milky Way with varying opacity and color
            const layers = [
                { opacity: 0.05, color: "rgba(180, 180, 255, 1)" }, // Faint outer edge, bluish
                { opacity: 0.1, color: "rgba(220, 220, 255, 1)" },  // Mid layer, light blue
                { opacity: 0.15, color: "rgba(255, 250, 240, 1)" }, // Inner layer, warm white
                { opacity: 0.2, color: "rgba(255, 240, 220, 1)" }   // Core, yellowish
            ];

            milkyWayData.forEach((feature, featureIndex) => {
                if (!feature.geometry || !feature.geometry.coordinates) return;

                // Choose layer based on feature index or properties
                const layerIndex = featureIndex % layers.length;
                const layer = layers[layerIndex];

                // Set blending mode for a more natural glow
                offCtx.globalCompositeOperation = "screen";

                feature.geometry.coordinates.forEach(polygon => {
                    if (!Array.isArray(polygon) || polygon.length === 0) return;

                    offCtx.beginPath();
                    let firstPoint = true;

                    // Draw the polygon
                    polygon.forEach(coordinates => {
                        if (!Array.isArray(coordinates) || coordinates.length < 2) return;

                        const ra = coordinates[0];
                        const dec = coordinates[1];

                        const [az, alt] = equatorialToHorizontal(ra, dec, lat, lst);

                        if (alt > 0) {
                            const [px, py] = transformCoords(az, alt);

                            if (firstPoint) {
                                offCtx.moveTo(px, py);
                                firstPoint = false;
                            } else {
                                offCtx.lineTo(px, py);
                            }
                        }
                    });

                    // Apply varying styles based on density/brightness
                    const brightness = feature.properties?.brightness || 1;
                    const adjustedOpacity = layer.opacity * (0.7 + brightness * 0.3);

                    // Fill with semi-transparent color
                    offCtx.closePath();
                    offCtx.fillStyle = layer.color;
                    offCtx.globalAlpha = adjustedOpacity;
                    offCtx.fill();

                    // Add a subtle blur effect to each layer
                    offCtx.filter = `blur(${2 + layerIndex}px)`;
                    offCtx.fill();
                    offCtx.filter = "none";
                });
            });

            // Add stars/sparkles effect within the Milky Way
            addMilkyWayStars(offCtx, milkyWayData, lat, lst);

            // Restore normal drawing settings
            offCtx.globalAlpha = 1;
            offCtx.globalCompositeOperation = "source-over";

            // Draw the off-screen canvas onto the main canvas
            ctx.drawImage(offCanvas, 0, 0);
        }

        // Add small bright points to represent dense star clusters in the Milky Way
        function addMilkyWayStars(context, milkyWayData, lat, lst) {
            // Dense star areas in the Milky Way
            const starDensity = 100; // Number of stars to add

            context.globalCompositeOperation = "lighten";

            // Create a collection of points within the Milky Way area
            const milkyWayPoints = [];

            milkyWayData.forEach(feature => {
                if (!feature.geometry || !feature.geometry.coordinates) return;

                feature.geometry.coordinates.forEach(polygon => {
                    if (!Array.isArray(polygon) || polygon.length === 0) return;

                    polygon.forEach((coordinates, i) => {
                        // Only sample some points to reduce computation
                        if (i % 3 !== 0) return;

                        if (!Array.isArray(coordinates) || coordinates.length < 2) return;

                        const ra = coordinates[0];
                        const dec = coordinates[1];

                        const [az, alt] = equatorialToHorizontal(ra, dec, lat, lst);

                        if (alt > 0) {
                            const [px, py] = transformCoords(az, alt);
                            milkyWayPoints.push([px, py]);
                        }
                    });
                });
            });

            // Draw random bright spots within the Milky Way
            for (let i = 0; i < starDensity && milkyWayPoints.length > 0; i++) {
                const pointIndex = Math.floor(Math.random() * milkyWayPoints.length);
                const [px, py] = milkyWayPoints[pointIndex];

                // Randomize the appearance
                const size = Math.random() * 1.5 + 0.5;
                const brightness = Math.random() * 0.5 + 0.5;

                // Vary the color slightly
                const r = 220 + Math.floor(Math.random() * 35);
                const g = 220 + Math.floor(Math.random() * 35);
                const b = 255;

                // Create a glow effect
                const gradient = context.createRadialGradient(px, py, 0, px, py, size * 2);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${brightness})`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                context.fillStyle = gradient;
                context.beginPath();
                context.arc(px, py, size * 2, 0, Math.PI * 2);
                context.fill();

                // Add a bright center
                context.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                context.beginPath();
                context.arc(px, py, size * 0.5, 0, Math.PI * 2);
                context.fill();
            }

            // For the galactic core - add extra brightness
            if (milkyWayPoints.length > 0) {
                // Assume the center of the Milky Way is around Sagittarius
                const sagittariusRA = 266; // Approximate RA of galactic center
                const sagittariusDEC = -29; // Approximate Dec of galactic center

                const [az, alt] = equatorialToHorizontal(sagittariusRA, sagittariusDEC, lat, lst);

                if (alt > 0) {
                    const [px, py] = transformCoords(az, alt);

                    // Create a bright core effect
                    const coreGradient = context.createRadialGradient(px, py, 0, px, py, 50);
                    coreGradient.addColorStop(0, "rgba(255, 240, 220, 0.5)");
                    coreGradient.addColorStop(0.4, "rgba(255, 220, 180, 0.3)");
                    coreGradient.addColorStop(1, "rgba(255, 220, 180, 0)");

                    context.fillStyle = coreGradient;
                    context.beginPath();
                    context.arc(px, py, 50, 0, Math.PI * 2);
                    context.fill();
                }
            }

            context.globalCompositeOperation = "source-over";
        }

        
        // function drawStars(stars, lat, lst) {
        //     stars.forEach(star => {
        //         const [ra, dec] = star.geometry.coordinates;
        //         const [az, alt] = equatorialToHorizontal(ra, dec, lat, lst);
                
        //         if (alt > 0) {
        //             const [px, py] = transformCoords(az, alt);
        //             const mag = star.properties.mag || 5;
        //             const bv = star.properties.bv || 0;
        //             const size = getMagnitudeSize(mag);
                    
        //             ctx.fillStyle = getStarColor(bv);
        //             ctx.beginPath();
        //             ctx.arc(px, py, size, 0, 2 * Math.PI);
        //             ctx.fill();
                    
        //             // For brightest stars only
        //             if (mag < 1.5 && star.properties.name) {
        //                 ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        //                 ctx.font = "10px Arial";
        //                 ctx.textAlign = "center";
        //                 ctx.fillText(star.properties.name, px, py - size - 3);
        //             }
        //         }
        //     });
        // }
        function drawStars(stars, lat, lst) {
            stars.forEach(star => {
                const [ra, dec] = star.geometry.coordinates;
            
                // Log RA, DEC, LAT, LST to verify values
                console.log(`Processing star with RA: ${ra}, DEC: ${dec}, LAT: ${lat}, LST: ${lst}`);
                
                const [az, alt] = equatorialToHorizontal(ra, dec, lat, lst);
                
                if (alt > 0) {
                    const [px, py] = transformCoords(az, alt);
                    const mag = star.properties.mag || 5;
                    const bv = star.properties.bv || 0;
                    const size = getMagnitudeSize(mag);
                    
                    ctx.fillStyle = getStarColor(bv);
                    ctx.beginPath();
                    ctx.arc(px, py, size, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // For brightest stars only
                    if (mag < 1.5 && star.properties.name) {
                        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                        ctx.font = "10px Arial";
                        ctx.textAlign = "center";
                        ctx.fillText(star.properties.name, px, py - size - 3);
                    }
                }
            });
        }

        
        function drawConstellations(constellations, lat, lst) {
            // Clear existing labels
            document.querySelectorAll('.constellation-label').forEach(el => el.remove());
            console.log("Drawing constellations, count:", constellations.length);

            const constellationHitboxes = [];

            // Draw constellation lines with improved visibility
            constellations.forEach(constellation => {
                const name = constellation.properties.name || constellation.id;
                console.log("Processing constellation:", name);

                // Check if coordinates are valid
                if (!constellation.geometry || !constellation.geometry.coordinates || !Array.isArray(constellation.geometry.coordinates)) {
                    console.error("Invalid constellation data format:", constellation);
                    return;
                }
                let allPoints = [];
                let validPointsCount = 0;
                let centerX = 0, centerY = 0;

                // Process each line segment in the constellation
                constellation.geometry.coordinates.forEach(line => {
                    if (!Array.isArray(line)) {
                        console.error("Invalid line data:", line);
                        return;
                    }

                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(120, 140, 220, 0.6)";
                    ctx.lineWidth = 1;

                    let firstPoint = true;

                    // Process each point in the line
                    line.forEach(point => {
                        if (!Array.isArray(point) || point.length < 2) {
                            console.error("Invalid point data:", point);
                            return;
                        }

                        const ra = point[0];
                        const dec = point[1];

                        // Check if the coordinates are valid numbers
                        if (isNaN(ra) || isNaN(dec)) {
                            console.error("Invalid coordinates:", ra, dec);
                            return;
                        }

                        const [az, alt] = equatorialToHorizontal(ra, dec, lat, lst);

                        if (isNaN(az) || isNaN(alt)) {
                            console.error("Invalid converted coordinates:", az, alt);
                            return;
                        }

                        if (alt > 0) {
                            const [px, py] = transformCoords(az, alt);

                            if (firstPoint) {
                                ctx.moveTo(px, py);
                                firstPoint = false;
                            } else {
                                ctx.lineTo(px, py);
                            }

                            // Track valid points for label positioning
                            allPoints.push([px, py]);
                            centerX += px;
                            centerY += py;
                            validPointsCount++;
                        }
                    });

                    ctx.stroke();
                });

                // Add label if there are valid points
                if (validPointsCount > 0) {
                    centerX /= validPointsCount;
                    centerY /= validPointsCount;

                    if (document.getElementById("showLabels").checked) {
                        const label = document.createElement("div");
                        label.className = "constellation-label";
                        label.textContent = name;
                        label.style.left = `${centerX}px`;
                        label.style.top = `${centerY}px`;
                        document.body.appendChild(label);
                    }
                    // Store constellation info for click detection
                    // Calculate bounding box for the constellation
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    allPoints.forEach(point => {
                        minX = Math.min(minX, point[0]);
                        minY = Math.min(minY, point[1]);
                        maxX = Math.max(maxX, point[0]);
                        maxY = Math.max(maxY, point[1]);
                    });

                    // Add padding to the bounding box
                    const padding = 7;
                    minX -= padding;
                    minY -= padding;
                    maxX += padding;
                    maxY += padding;

                    // Store the constellation info and its bounding box
                    constellationHitboxes.push({
                        name: name,
                        id: constellation.id,
                        box: {minX, minY, maxX, maxY},
                        center: {x: centerX, y: centerY},
                        description: constellation.properties.description || getConstellationDescription(name)
                    });
                }
            });
            // Add click listener to the canvas
            canvas.onclick = function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                // Check if click is within any constellation bounding box
                for (let i = 0; i < constellationHitboxes.length; i++) {
                    const hitbox = constellationHitboxes[i].box;
                    if (x >= hitbox.minX && x <= hitbox.maxX && y >= hitbox.minY && y <= hitbox.maxY) {
                        showConstellationInfo(constellationHitboxes[i], event.clientX, event.clientY);
                        return;
                    }
                }

                // If click is not on any constellation, hide the popup
                hideConstellationInfo();
            };

            // Update constellation count
            const visibleConstellations = constellations.filter(c => {
                if (!c.geometry || !c.geometry.coordinates) return false;

                // Check if any point in any line is above horizon
                return c.geometry.coordinates.some(line => {
                    if (!Array.isArray(line)) return false;

                    return line.some(point => {
                        if (!Array.isArray(point) || point.length < 2) return false;

                        const [ra, dec] = point;
                        if (isNaN(ra) || isNaN(dec)) return false;

                        const [az, alt] = equatorialToHorizontal(ra, dec, lat, lst);
                        return !isNaN(alt) && alt > 0;
                    });
                });
            });

            // constellationInfo.textContent = `Visible Constellations: ${visibleConstellations.length}`;
        } 
        
        // Function to show constellation info popup
        function showConstellationInfo(constellation, clientX, clientY) {
            const popup = document.getElementById('constellation-popup');
            const title = document.getElementById('popup-title');
            const descriptionContainer= document.getElementById('popup-description');

            title.textContent = constellation.name;
            // Clear previous content
            descriptionContainer.innerHTML = '';

            // Create elements for name, meaning, and mythology
            const nameElement = document.createElement('h2');
            nameElement.textContent = constellation.description.name;
            nameElement.classList.add('constellation-name'); // Add a class for styling

            const meaningElement = document.createElement('p');
            meaningElement.innerHTML = `<strong>Meaning:</strong> ${constellation.description.meaning || 'Meaning not available.'}`; // Use innerHTML for potential formatting
            meaningElement.classList.add('constellation-meaning');

            const mythologyElement = document.createElement('p');
            mythologyElement.innerHTML = `<strong>Mythology:</strong> ${constellation.description.mythology || 'Mythology not available.'}`;
            mythologyElement.classList.add('constellation-mythology');

            // Append elements to the container
            descriptionContainer.appendChild(nameElement);
            descriptionContainer.appendChild(meaningElement);
            descriptionContainer.appendChild(mythologyElement);

            // Position the popup near the click but ensure it's visible
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const popupWidth = 300; // Max width of the popup

            // Calculate position to ensure popup stays within viewport
            let left = clientX + 10;
            if (left + popupWidth > viewportWidth) {
                left = clientX - popupWidth - 10;
            }

            let top = clientY + 10;
            if (top + 200 > viewportHeight) { // Assume max height of 200px
                top = clientY - 200 - 10;
            }

            popup.style.left = `${left}px`;
            popup.style.top = `${top}px`;
            popup.style.display = 'block';
        }

        // Function to hide constellation info popup
        function hideConstellationInfo() {
            const popup = document.getElementById('constellation-popup');
            popup.style.display = 'none';
        }

        // Function to get constellation descriptions
        function getConstellationDescription(name) {
            // Basic descriptions for common constellations
            // const descriptions = {
            //     "Orion": "One of the most recognizable constellations, representing the hunter from Greek mythology. Contains the bright stars Betelgeuse and Rigel.",
            //     "Ursa Major": "The Great Bear, which contains the Big Dipper. One of the most prominent constellations in the northern sky.",
            //     "Ursa Minor": "The Little Bear, which contains the North Star (Polaris) at the end of its tail.",
            //     "Cassiopeia": "Named after the queen in Greek mythology, recognizable by its distinctive W shape.",
            //     "Cygnus": "The Swan, also known as the Northern Cross. Located along the Milky Way.",
            //     "Lyra": "A small constellation containing the bright star Vega, one of the brightest stars in the night sky.",
            //     "Scorpius": "Represents the scorpion that killed Orion in Greek mythology. Contains the bright red star Antares.",
            //     "Leo": "Represents the Nemean Lion from the 12 labors of Hercules. Contains the bright star Regulus.",
            //     "Gemini": "The Twins, representing Castor and Pollux from Greek mythology.",
            //     "Taurus": "The Bull, containing the bright star Aldebaran and the Pleiades star cluster.",
            //     "Aquila": "The Eagle, containing the bright star Altair.",
            //     "Canis Major": "The Great Dog, containing Sirius, the brightest star in the night sky.",
            //     "Andromeda": "Named after the princess in Greek mythology. Contains the Andromeda Galaxy, the nearest major galaxy to the Milky Way.",
            //     "Pisces": "The Fish, representing Venus and Cupid in Roman mythology.",
            //     "Sagittarius": "The Archer, pointing towards the center of the Milky Way galaxy.",
            //     "Draco": "The Dragon, a circumpolar constellation in the northern sky.",
            //     "Boötes": "The Herdsman, containing the bright star Arcturus.",
            //     "Perseus": "Named after the hero in Greek mythology who slew Medusa."
            // };
            const descriptions = { 
                "constellations": [
                    {
                        "name": "Andromeda",
                        "meaning": "Princess of Ethiopia",
                        "mythology": "Represents the princess Andromeda, who was chained to a rock as a sacrifice to a sea monster and later rescued by Perseus."
                    },
                    {
                        "name": "Auriga",
                        "meaning": "Charioteer",
                        "mythology": "Associated with various charioteers in Greek mythology, often depicted holding a goat and its kids."
                    },
                    {
                        "name": "Boötes",
                        "meaning": "Herdsman",
                        "mythology": "Represents a herdsman or plowman in Greek mythology, sometimes associated with the invention of the plow."
                    },
                    {
                        "name": "Camelopardalis",
                        "meaning": "Giraffe",
                        "mythology": "Represents a giraffe; the name is derived from the camel and leopard due to its long neck and spots."
                    },
                    {
                        "name": "Cancer",
                        "meaning": "Crab",
                        "mythology": "Represents the crab that attacked Hercules during his fight with the Hydra in Greek mythology."
                    },
                    {
                        "name": "Canes Venatici",
                        "meaning": "Hunting Dogs",
                        "mythology": "Represents the hunting dogs of Boötes, the herdsman."
                    },
                    {
                        "name": "Canis Minor",
                        "meaning": "Little Dog",
                        "mythology": "Represents one of the hunting dogs following Orion, the hunter."
                    },
                    {
                        "name": "Cassiopeia",
                        "meaning": "Queen of Ethiopia",
                        "mythology": "Represents Queen Cassiopeia, mother of Andromeda, known for her vanity."
                    },
                    {
                        "name": "Cepheus",
                        "meaning": "King of Ethiopia",
                        "mythology": "Represents King Cepheus, husband of Cassiopeia and father of Andromeda."
                    },
                    {
                        "name": "Coma Berenices",
                        "meaning": "Berenice's Hair",
                        "mythology": "Represents the hair of Queen Berenice II of Egypt, who sacrificed her locks for her husband's safe return."
                    },
                    {
                        "name": "Corona Borealis",
                        "meaning": "Northern Crown",
                        "mythology": "Represents the crown given by Dionysus to Ariadne after rescuing her."
                    },
                    {
                        "name": "Cygnus",
                        "meaning": "Swan",
                        "mythology": "Represents a swan; associated with various myths, including Zeus disguising himself as a swan."
                    },
                    {
                        "name": "Delphinus",
                        "meaning": "Dolphin",
                        "mythology": "Represents a dolphin; associated with the story of Arion, a poet saved by dolphins."
                    },
                    {
                        "name": "Draco",
                        "meaning": "Dragon",
                        "mythology": "Represents the dragon slain by Cadmus in Greek mythology."
                    },
                    {
                        "name": "Equuleus",
                        "meaning": "Little Horse",
                        "mythology": "Represents a small horse; associated with Celeris, the offspring or brother of Pegasus."
                    },
                    {
                        "name": "Gemini",
                        "meaning": "Twins",
                        "mythology": "Represents the twin brothers Castor and Pollux from Greek mythology."
                    },
                    {
                        "name": "Hercules",
                        "meaning": "Hercules, son of Zeus",
                        "mythology": "Represents Hercules, the Roman name for the Greek hero Heracles, known for his strength and twelve labors."
                    },
                    {
                        "name": "Lacerta",
                        "meaning": "Lizard",
                        "mythology": "Represents a lizard; introduced in the 17th century and not associated with any particular myth."
                    },
                    {
                        "name": "Leo",
                        "meaning": "Lion",
                        "mythology": "Represents the Nemean Lion, slain by Hercules as one of his twelve labors."
                    },
                    {
                        "name": "Leo Minor",
                        "meaning": "Little Lion",
                        "mythology": "Represents a small lion; introduced in the 17th century and not associated with any particular myth."
                    },
                    {
                        "name": "Lynx",
                        "meaning": "Lynx",
                        "mythology": "Represents a lynx; introduced in the 17th century and not associated with any particular myth."
                    },
                    {
                        "name": "Lyra",
                        "meaning": "Lyre or Harp",
                        "mythology": "Represents the lyre of Orpheus, a musician who could charm all living things."
                    },
                    {
                        "name": "Ophiuchus",
                        "meaning": "Holder of Serpent",
                        "mythology": "Represents Asclepius, the Greek god of medicine, holding a serpent."
                    },
                    {
                        "name": "Pegasus",
                        "meaning": "Winged Horse",
                        "mythology": "Represents the winged horse Pegasus, born from the blood of Medusa after she was slain by Perseus."
                    },
                    {
                        "name": "Perseus",
                        "meaning": "Hero who saved Andromeda",
                        "mythology": "Represents Perseus, the hero who slew Medusa and rescued Andromeda."
                    },
                    {
                        "name": "Sagitta",
                        "meaning": "Arrow",
                        "mythology": "Represents an arrow; associated with various myths, including the arrow used by Hercules to kill the eagle tormenting Prometheus."
                    },
                    {
                        "name": "Sagittarius",
                        "meaning": "Archer",
                        "mythology": "Represents a centaur archer; often associated with the wise centaur Chiron."
                    },
                    {
                        "name": "Scutum",
                        "meaning": "Shield",
                        "mythology": "Represents a shield; introduced in the 17th century to honor King John III Sobieski of Poland."
                    },
                    {
                        "name": "Serpens",
                        "meaning": "Serpent",
                        "mythology": "Represents a serpent held by Ophiuchus, the serpent bearer."
                    },
                    {
                        "name": "Taurus",
                        "meaning": "Bull",
                        "mythology": "Represents the bull form taken by Zeus to abduct Europa."
                    },
                    {
                        "name": "Triangulum",
                        "meaning": "Triangle",
                        "mythology": "Represents a triangle; associated with the Nile Delta or the island of Sicily in different myths."
                    },
                    {
                        "name": "Ursa Major",
                        "meaning": "Big Bear",
                        "mythology": "Represents Callisto, a nymph transformed into a bear and placed in the sky by Zeus."
                    },
                    {
                        "name": "Ursa Minor",
                        "meaning": "Little Bear",
                        "mythology": "Represents Arcas, the son of Callisto, who was transformed into a bear and placed in the sky by Zeus alongside his mother."
                    },
                    {
                        "name": "Vulpecula",
                        "meaning": "Fox",
                        "mythology": "Represents a small fox; introduced in the 17th century and not associated with any particular myth."
                    }
                ]}
            
            for (var i = 0; i < descriptions.constellations.length; i++) {
                if (descriptions.constellations[i].name.toLowerCase() == name.toLowerCase()) {
                    return descriptions.constellations[i];
                }
            }
            return `${name} is one of the 88 modern constellations recognized by the International Astronomical Union.`;
        }

        function drawHorizon() {
            // Draw horizon circle
            const radius = Math.min(canvas.width, canvas.height) / 2 * 0.9;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = "rgba(100, 100, 150, 0.5)";
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw cardinal directions
            const directions = [
                { angle: 0, text: "N" },
                { angle: 90, text: "E" },
                { angle: 180, text: "S" },
                { angle: 270, text: "W" }
            ];
            
            ctx.font = "14px Arial";
            ctx.fillStyle = "rgba(180, 180, 220, 0.8)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            directions.forEach(dir => {
                const [px, py] = transformCoords(dir.angle, 0);
                ctx.fillText(dir.text, px, py);
            });
        }

        function drawCaption(location, date) {
            // ctx.fillStyle = "white";
            // ctx.font = "20px Arial";
            // ctx.textAlign = "center";
            // ctx.fillText("NIGHT SKY MAP", canvas.width / 2, canvas.height - 80);
            // ctx.fillText(location, canvas.width / 2, canvas.height - 50);
            // ctx.fillText(date, canvas.width / 2, canvas.height - 20);
        }
        
        async function initializeData() {
            // Load data once
            try {
                const data = await loadStars();
                starData = data.stars;
                constellationData = data.constellations;
                milkyWayData = data.milkyWay;
                updateSkyMap();
            } catch (error) {
                console.error("Failed to initialize data:", error);
                statusDiv.textContent = "Failed to load star data. Please try again.";
            }
        }
        
        function updateSkyMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Use current date if not specified
            // get the date from the URL query parameter
            // if no query parameter specified then set default date to today
            const urlParams = new URLSearchParams(window.location.search); 
            let today;

            // Check if date parameter exists in URL
            if (urlParams.has('date') && urlParams.get('date')) {
                // Convert string date to Date object
                const dateString = urlParams.get('date');
                today = new Date(dateString);

                // Fallback in case the date is invalid
                if (isNaN(today.getTime())) {
                    today = new Date();
                }
            } else {
                // Default to today if no date parameter
                today = new Date();
            }

            // Format the date as YYYY-MM-DD
            const date = today.toISOString().split('T')[0];
            
            // const lat = parseFloat(document.getElementById("latitude").value);
            // const lon = parseFloat(document.getElementById("longitude").value);
            // calculate longitude and latitude
            let lat, lon;
            if (date === '2024-09-22' || date === '2025-02-28' || date === '2025-03-22') {
                lat = 51.759445;
                lon = 19.457216;
            } else {
                lat = 52.237049;
                lon = 21.017532;
            }
            const lst = localSiderealTime(date, lon);
            
            // Draw sky background gradient
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, Math.min(canvas.width, canvas.height) / 2
            );
            gradient.addColorStop(0, "#0a0e1a");
            gradient.addColorStop(1, "#000005");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw only if data is loaded
            if (starData.length > 0) {
                drawHorizon();

                // Draw Milky Way first as background
                if (milkyWayData.length > 0) {
                    drawMilkyWay(milkyWayData, lat, lst);
                }

                drawConstellations(constellationData, lat, lst);
                drawStars(starData, lat, lst);

                // Format the date nicely
                const formattedDate = new Date(date).toLocaleDateString('en-US', {
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric'
                });
                
                drawCaption(`Lat: ${lat.toFixed(2)}°, Lon: ${lon.toFixed(2)}°`, formattedDate);
            } else {
                statusDiv.textContent = "No star data available. Try reloading the page.";
            }
        }
        
        // Initialize
        initializeData();
        
        // Add event listener for checkbox
        document.getElementById("showLabels").addEventListener("change", function() {
            window.requestAnimationFrame(() => {
                updateSkyMap();
            })
        });
        document.getElementById("showMilkyWay").addEventListener("change",  function() {
            const loadingSpinner = document.getElementById('loadingSpinner');
            loadingSpinner.style.display = 'flex';
            
            this.disabled = true;
            window.requestAnimationFrame(() => {
                updateSkyMap();
                hideSpinner
            });
            setTimeout(hideSpinner, 3000);
        });
        function hideSpinner() {
            const loadingSpinner = document.getElementById('loadingSpinner');
            loadingSpinner.style.display = 'none';

            // Re-enable the checkbox after the spinner is hidden
            document.getElementById("showLabels").disabled = false;
            document.getElementById("showMilkyWay").disabled = false;
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('close-popup').addEventListener('click', hideConstellationInfo);
        });
    </script>
</body>
</html>
<!------------------------------------------------------------------------------------->